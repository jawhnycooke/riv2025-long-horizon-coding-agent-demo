# GitHub Actions workflow to trigger AgentCore when admin approves a feature
#
# Trigger: Admin adds ðŸš€ reaction to an issue
# Action: Invokes AWS Bedrock AgentCore to build the feature
#
# Prerequisites:
# 1. AWS OIDC provider configured for GitHub Actions
# 2. IAM role with permissions to invoke AgentCore
# 3. Secrets: AWS_ROLE_ARN (or configure in this file)

name: Agent Builder

on:
  # Only trigger via workflow_dispatch (from issue-poller or manual)
  # Removed issue_comment and issues triggers to prevent race conditions
  # when agent adds labels/comments during issue transitions.
  # The poller handles all cases: new issues, crash recovery, etc.
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to build'
        required: true
        type: number
      force_rebuild:
        description: 'Force rebuild even if already building'
        required: false
        type: boolean
        default: false
      resume_session:
        description: 'Resume from previous session (reads state from EFS)'
        required: false
        type: boolean
        default: false

# Prevent concurrent builds of the same issue
concurrency:
  group: agent-build-${{ github.event.inputs.issue_number || github.event.issue.number }}
  cancel-in-progress: false

permissions:
  issues: write
  contents: read
  actions: write

env:
  AWS_REGION: us-west-2  # AgentCore deployed in us-west-2
  AGENTCORE_AGENT_ID: antodo_agent-0UyfaL5NVq

jobs:
  # Check if the issue is approved and ready to build
  check-approval:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      should_build: ${{ steps.check.outputs.should_build }}
      should_invoke: ${{ steps.check.outputs.should_invoke }}
      issue_number: ${{ steps.check.outputs.issue_number }}
      issue_title: ${{ steps.check.outputs.issue_title }}
      issue_body: ${{ steps.check.outputs.issue_body }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: |
          pip install PyGithub

      - name: Check issue approval status
        id: check
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number }}
          RESUME_SESSION: ${{ github.event.inputs.resume_session || 'false' }}
          AUTHORIZED_APPROVERS: ${{ vars.AUTHORIZED_APPROVERS }}
        run: |
          python << 'EOF'
          import os
          import json
          from github import Github

          # Authorized approvers who can trigger builds with ðŸš€
          # Configure via AUTHORIZED_APPROVERS repository variable (comma-separated)
          _approvers_env = os.environ.get("AUTHORIZED_APPROVERS", "")
          AUTHORIZED_APPROVERS = set(a.strip() for a in _approvers_env.split(",") if a.strip())
          LABEL_BUILDING = "agent-building"

          # Check if this is a resume request (skip label checks)
          resume_session = os.environ.get("RESUME_SESSION", "false").lower() == "true"

          gh = Github(os.environ["GITHUB_TOKEN"])
          repo = gh.get_repo(os.environ["GITHUB_REPOSITORY"])

          issue_number = os.environ.get("ISSUE_NUMBER")
          if not issue_number:
              print("No issue number provided")
              with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                  f.write("should_build=false\n")
                  f.write("should_invoke=false\n")
              exit(0)

          issue = repo.get_issue(int(issue_number))

          # For resume requests, skip the "already building" check
          # The previous session timed out and we need to restart
          if resume_session:
              print(f"ðŸ”„ Resume mode: Restarting session for issue #{issue_number}")
              # Output issue details and proceed
              with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                  f.write("should_build=true\n")
                  f.write("should_invoke=true\n")
                  f.write(f"issue_number={issue_number}\n")
                  title = issue.title.replace('\n', ' ')
                  f.write(f"issue_title={title}\n")
                  body = issue.body or ""
                  body_escaped = body.replace('%', '%25').replace('\n', '%0A').replace('\r', '%0D')
                  f.write(f"issue_body={body_escaped}\n")
              exit(0)

          # Check if issue is still open
          if issue.state != 'open':
              print(f"Issue #{issue_number} is closed - skipping")
              with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                  f.write("should_build=false\n")
                  f.write("should_invoke=false\n")
              exit(0)

          # Check if THIS issue already has building or complete label
          labels = [l.name for l in issue.labels]
          if LABEL_BUILDING in labels:
              print(f"Issue #{issue_number} is already being built")
              with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                  f.write("should_build=false\n")
                  f.write("should_invoke=false\n")
              exit(0)

          if "agent-complete" in labels:
              print(f"Issue #{issue_number} is already complete")
              with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                  f.write("should_build=false\n")
                  f.write("should_invoke=false\n")
              exit(0)

          # Check for staff approval (ðŸš€ reaction)
          approved = False
          approvers = []
          for reaction in issue.get_reactions():
              if reaction.content == "rocket" and reaction.user.login in AUTHORIZED_APPROVERS:
                  approved = True
                  approvers.append(reaction.user.login)

          if not approved:
              print(f"Issue #{issue_number} not approved by staff (needs ðŸš€ from {AUTHORIZED_APPROVERS})")
              with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                  f.write("should_build=false\n")
                  f.write("should_invoke=false\n")
              exit(0)

          print(f"Issue #{issue_number} approved by: {approvers}")

          # Check if ANY OTHER issue has agent-building label (session already running)
          # If so, we don't need to invoke AgentCore - the running agent will pick up this issue
          session_already_running = False
          for other_issue in repo.get_issues(state='open', labels=[LABEL_BUILDING]):
              if other_issue.number != int(issue_number):
                  print(f"Session already running for issue #{other_issue.number}")
                  print(f"The running agent will pick up issue #{issue_number} automatically")
                  session_already_running = True
                  break

          # Output issue details for the build job
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write("should_build=true\n")
              # Only invoke AgentCore if no session is running
              f.write(f"should_invoke={'false' if session_already_running else 'true'}\n")
              f.write(f"issue_number={issue_number}\n")
              # Escape newlines for GitHub Actions
              title = issue.title.replace('\n', ' ')
              f.write(f"issue_title={title}\n")
              # Body needs special handling for multiline
              body = issue.body or ""
              body_escaped = body.replace('%', '%25').replace('\n', '%0A').replace('\r', '%0D')
              f.write(f"issue_body={body_escaped}\n")

          EOF

      # F020: Write job summary for visibility
      - name: Write job summary
        if: always()
        env:
          SHOULD_BUILD: ${{ steps.check.outputs.should_build }}
          SHOULD_INVOKE: ${{ steps.check.outputs.should_invoke }}
          ISSUE_NUMBER: ${{ steps.check.outputs.issue_number }}
          ISSUE_TITLE: ${{ steps.check.outputs.issue_title }}
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOFSUM'
          ## Agent Build Check Results

          | Field | Value |
          |-------|-------|
          EOFSUM

          echo "| Issue | #${ISSUE_NUMBER:-N/A} |" >> $GITHUB_STEP_SUMMARY
          echo "| Title | ${ISSUE_TITLE:-N/A} |" >> $GITHUB_STEP_SUMMARY
          echo "| Should Build | ${SHOULD_BUILD:-false} |" >> $GITHUB_STEP_SUMMARY
          echo "| Should Invoke | ${SHOULD_INVOKE:-false} |" >> $GITHUB_STEP_SUMMARY

          if [ "$SHOULD_BUILD" = "true" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo ":white_check_mark: Issue approved and ready for build" >> $GITHUB_STEP_SUMMARY
          else
            echo "" >> $GITHUB_STEP_SUMMARY
            echo ":x: Issue not approved or already building" >> $GITHUB_STEP_SUMMARY
          fi

  # Acquire a global lock to prevent race conditions
  # Only one workflow can be in this job at a time across ALL issues
  # F007: Added jitter, timeout detection, stale lock release, and status outputs
  acquire-runtime-lock:
    needs: check-approval
    if: needs.check-approval.outputs.should_build == 'true' && needs.check-approval.outputs.should_invoke == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    # GLOBAL concurrency group - only one workflow can be in this job at a time
    concurrency:
      group: agentcore-runtime-global-lock
      cancel-in-progress: false
    outputs:
      lock_acquired: ${{ steps.acquire.outputs.lock_acquired }}
      lock_age_seconds: ${{ steps.acquire.outputs.lock_age_seconds }}
      stale_lock_released: ${{ steps.acquire.outputs.stale_lock_released }}
      lock_holder_issue: ${{ steps.acquire.outputs.lock_holder_issue }}

    steps:
      # F020: Checkout to access shared scripts
      - name: Checkout repository
        uses: actions/checkout@v4

      # F007: Add jitter before lock acquisition to reduce thundering herd
      - name: Apply lock acquisition jitter
        id: jitter
        run: |
          # Random delay between 0-5 seconds to stagger concurrent requests
          JITTER=$((RANDOM % 6))
          echo "â³ Waiting ${JITTER}s before lock acquisition (jitter)"
          echo "jitter_seconds=$JITTER" >> $GITHUB_OUTPUT
          sleep $JITTER

      - name: Acquire runtime lock and set label atomically
        id: acquire
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ needs.check-approval.outputs.issue_number }}
          # F007: Configurable lock timeout (default 10 minutes = 600 seconds)
          LOCK_TIMEOUT_SECONDS: ${{ vars.LOCK_TIMEOUT_SECONDS || '600' }}
        run: |
          # CRITICAL: Check for label AND set label atomically while holding the global lock
          # This prevents race condition where two workflows both pass the check before either sets label

          # Initialize outputs
          echo "lock_age_seconds=0" >> $GITHUB_OUTPUT
          echo "stale_lock_released=false" >> $GITHUB_OUTPUT
          echo "lock_holder_issue=" >> $GITHUB_OUTPUT

          # Re-check if any other issue has agent-building label NOW (inside the lock)
          BUILDING_ISSUES=$(gh api repos/$GITHUB_REPOSITORY/issues \
            -q '.[] | select(.labels[].name == "agent-building") | .number' \
            2>/dev/null || echo "")

          if [ -n "$BUILDING_ISSUES" ]; then
            # Check if any building issue is NOT our issue
            for ISSUE in $BUILDING_ISSUES; do
              if [ "$ISSUE" != "$ISSUE_NUMBER" ]; then
                echo "lock_holder_issue=$ISSUE" >> $GITHUB_OUTPUT

                # F007: Check lock age and release if stale
                echo "ðŸ” Checking lock age for issue #$ISSUE..."

                # Get the timestamp when agent-building label was added
                # Query issue events to find when the label was added
                LABEL_ADDED_AT=$(gh api repos/$GITHUB_REPOSITORY/issues/$ISSUE/events \
                  --jq '[.[] | select(.event == "labeled" and .label.name == "agent-building")] | last | .created_at' \
                  2>/dev/null || echo "")

                if [ -n "$LABEL_ADDED_AT" ] && [ "$LABEL_ADDED_AT" != "null" ]; then
                  # Calculate lock age in seconds
                  LABEL_EPOCH=$(date -d "$LABEL_ADDED_AT" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$LABEL_ADDED_AT" +%s 2>/dev/null || echo "0")
                  NOW_EPOCH=$(date +%s)
                  LOCK_AGE=$((NOW_EPOCH - LABEL_EPOCH))

                  echo "lock_age_seconds=$LOCK_AGE" >> $GITHUB_OUTPUT
                  echo "ðŸ“Š Lock held by issue #$ISSUE for ${LOCK_AGE}s (timeout: ${LOCK_TIMEOUT_SECONDS}s)"

                  # F007: Release stale lock if timeout exceeded
                  if [ "$LOCK_AGE" -gt "$LOCK_TIMEOUT_SECONDS" ]; then
                    echo "âš ï¸ Stale lock detected (${LOCK_AGE}s > ${LOCK_TIMEOUT_SECONDS}s timeout)"
                    echo "ðŸ”“ Releasing stale lock from issue #$ISSUE..."

                    # Remove the agent-building label from the stale issue
                    gh issue edit $ISSUE --remove-label "agent-building" --repo $GITHUB_REPOSITORY

                    # Add a comment explaining why the lock was released
                    gh issue comment $ISSUE --repo $GITHUB_REPOSITORY --body "âš ï¸ **Stale Lock Released**

          The agent-building lock was held for ${LOCK_AGE} seconds, exceeding the timeout of ${LOCK_TIMEOUT_SECONDS} seconds.

          The lock has been released to allow other issues to be processed.

          **Possible causes:**
          - Agent session crashed or timed out
          - CloudWatch heartbeat stopped
          - Network connectivity issues

          To restart this build, add a ðŸš€ reaction again or use \`resume_session=true\` in the workflow."

                    echo "stale_lock_released=true" >> $GITHUB_OUTPUT
                    echo "âœ… Stale lock released from issue #$ISSUE"

                    # Continue to acquire the lock for our issue
                  else
                    echo "Another issue #$ISSUE is already building (lock age: ${LOCK_AGE}s)"
                    echo "The running agent will pick up issue #$ISSUE_NUMBER automatically"
                    echo "lock_acquired=false" >> $GITHUB_OUTPUT
                    echo "label_set=false" >> $GITHUB_OUTPUT
                    exit 0
                  fi
                else
                  # Can't determine lock age, assume it's valid
                  echo "âš ï¸ Could not determine lock age for issue #$ISSUE"
                  echo "Another issue #$ISSUE is already building (detected inside lock)"
                  echo "The running agent will pick up issue #$ISSUE_NUMBER automatically"
                  echo "lock_acquired=false" >> $GITHUB_OUTPUT
                  echo "label_set=false" >> $GITHUB_OUTPUT
                  exit 0
                fi
              fi
            done
          fi

          # No other issue is building (or stale lock was released) - SET THE LABEL NOW while we hold the lock
          # This is the atomic operation that prevents races
          echo "ðŸ”’ Lock acquired - setting agent-building label while holding lock"
          gh issue edit $ISSUE_NUMBER --add-label "agent-building" --repo $GITHUB_REPOSITORY

          echo "lock_acquired=true" >> $GITHUB_OUTPUT
          echo "label_set=true" >> $GITHUB_OUTPUT
          echo "lock_holder_issue=$ISSUE_NUMBER" >> $GITHUB_OUTPUT

      # F020: Write lock acquisition summary
      - name: Write lock summary
        if: always()
        env:
          LOCK_ACQUIRED: ${{ steps.acquire.outputs.lock_acquired }}
          LOCK_AGE: ${{ steps.acquire.outputs.lock_age_seconds }}
          STALE_RELEASED: ${{ steps.acquire.outputs.stale_lock_released }}
          LOCK_HOLDER: ${{ steps.acquire.outputs.lock_holder_issue }}
          JITTER: ${{ steps.jitter.outputs.jitter_seconds }}
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOFSUM
          ## Lock Acquisition Results

          | Field | Value |
          |-------|-------|
          | Jitter Applied | ${JITTER:-0}s |
          | Lock Acquired | ${LOCK_ACQUIRED:-false} |
          | Lock Holder | #${LOCK_HOLDER:-N/A} |
          | Lock Age | ${LOCK_AGE:-0}s |
          | Stale Lock Released | ${STALE_RELEASED:-false} |
          EOFSUM

  # Post comment about build status
  # Label is set atomically in acquire-runtime-lock for should_invoke=true cases
  # For should_invoke=false (queued), we set the label here
  mark-building:
    needs: [check-approval, acquire-runtime-lock]
    if: |
      needs.check-approval.outputs.should_build == 'true' &&
      (needs.check-approval.outputs.should_invoke == 'false' || needs.acquire-runtime-lock.outputs.lock_acquired == 'true')
    runs-on: ubuntu-latest
    timeout-minutes: 5
    # Same global concurrency group to maintain lock during operations
    concurrency:
      group: agentcore-runtime-global-lock
      cancel-in-progress: false

    steps:
      - name: Add label (if queued) and post comment
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ needs.check-approval.outputs.issue_number }}
          SHOULD_INVOKE: ${{ needs.check-approval.outputs.should_invoke }}
          # F007: Include lock status information
          STALE_LOCK_RELEASED: ${{ needs.acquire-runtime-lock.outputs.stale_lock_released || 'false' }}
          LOCK_AGE_SECONDS: ${{ needs.acquire-runtime-lock.outputs.lock_age_seconds || '0' }}
          LOCK_HOLDER_ISSUE: ${{ needs.acquire-runtime-lock.outputs.lock_holder_issue || '' }}
        run: |
          # Add comment depending on whether we're starting a new session or queuing
          if [ "$SHOULD_INVOKE" = "true" ]; then
            # Label already set in acquire-runtime-lock (atomically while holding lock)

            # F007: Include stale lock release info if applicable
            if [ "$STALE_LOCK_RELEASED" = "true" ]; then
              LOCK_INFO="
          > âš ï¸ **Note:** A stale lock from issue #${LOCK_HOLDER_ISSUE} (held for ${LOCK_AGE_SECONDS}s) was automatically released.
          "
            else
              LOCK_INFO=""
            fi

            gh issue comment $ISSUE_NUMBER --repo $GITHUB_REPOSITORY --body "ðŸ¤– **Agent Build Started**

          Workflow: [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          Started: $(date -u +%Y-%m-%dT%H:%M:%SZ)
          Lock timeout: \${{ vars.LOCK_TIMEOUT_SECONDS || '600' }}s
          ${LOCK_INFO}
          The agent is now building this feature. Progress will be posted here.

          Commits will be pushed to branch \`agent-runtime\`."
          else
            # Queued case: acquire-runtime-lock didn't run, so we need to set the label here
            gh issue edit $ISSUE_NUMBER --add-label "agent-building" --repo $GITHUB_REPOSITORY
            gh issue comment $ISSUE_NUMBER --repo $GITHUB_REPOSITORY --body "ðŸ¤– **Issue Queued for Build**

          Workflow: [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          Queued: $(date -u +%Y-%m-%dT%H:%M:%SZ)

          An agent session is already running. This issue has been added to the queue and will be picked up automatically when the current issue completes.

          Commits will be pushed to branch \`agent-runtime\`."
          fi

  # Invoke AWS Bedrock AgentCore to build the feature
  # Only invoke if no session is already running AND we acquired the lock
  invoke-agent:
    needs: [check-approval, acquire-runtime-lock, mark-building]
    if: |
      needs.check-approval.outputs.should_build == 'true' &&
      needs.check-approval.outputs.should_invoke == 'true' &&
      needs.acquire-runtime-lock.outputs.lock_acquired == 'true'
    runs-on: ubuntu-latest
    outputs:
      session_id: ${{ steps.invoke.outputs.session_id }}
      success: ${{ steps.invoke.outputs.success }}

    # Set timeout for long-running agent (8 hours max)
    timeout-minutes: 480

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_AGENTCORE_ROLE_ARN }}
          role-duration-seconds: 28800  # 8 hours for long agent runs

      - name: Verify issue still open before invoke
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ needs.check-approval.outputs.issue_number }}
        run: |
          # Re-check issue state right before invoking (may have been closed during queue wait)
          STATE=$(gh issue view $ISSUE_NUMBER --repo $GITHUB_REPOSITORY --json state --jq '.state')
          if [ "$STATE" != "OPEN" ]; then
            echo "Issue #$ISSUE_NUMBER is $STATE - aborting invoke"
            # Remove the agent-building label since we're not building
            gh issue edit $ISSUE_NUMBER --repo $GITHUB_REPOSITORY --remove-label "agent-building" || true
            exit 1
          fi
          echo "Issue #$ISSUE_NUMBER is still open - proceeding with invoke"

      - name: Invoke AgentCore
        id: invoke
        env:
          ISSUE_NUMBER: ${{ needs.check-approval.outputs.issue_number }}
          ISSUE_TITLE: ${{ needs.check-approval.outputs.issue_title }}
          ISSUE_BODY: ${{ needs.check-approval.outputs.issue_body }}
          RESUME_SESSION: ${{ github.event.inputs.resume_session || 'false' }}
        run: |
          # Generate a unique session ID (min 33 chars required by AWS)
          SESSION_ID="gh-issue-${ISSUE_NUMBER}-$(date +%Y%m%d-%H%M%S)-${GITHUB_RUN_ID}"
          echo "session_id=$SESSION_ID" >> $GITHUB_OUTPUT

          # Prepare the payload for AgentCore
          # Decode the escaped body
          DECODED_BODY=$(echo "$ISSUE_BODY" | sed 's/%0A/\n/g' | sed 's/%0D/\r/g' | sed 's/%25/%/g')

          # Convert resume_session to boolean for JSON
          if [ "$RESUME_SESSION" = "true" ]; then
            RESUME_FLAG="true"
          else
            RESUME_FLAG="false"
          fi

          PAYLOAD=$(cat << EOFPAYLOAD
          {
            "mode": "build-from-issue",
            "issue_number": $ISSUE_NUMBER,
            "issue_title": "$ISSUE_TITLE",
            "issue_body": $(echo "$DECODED_BODY" | jq -Rs .),
            "github_repo": "$GITHUB_REPOSITORY",
            "branch_name": "agent-runtime",
            "session_id": "$SESSION_ID",
            "resume_session": $RESUME_FLAG
          }
          EOFPAYLOAD
          )

          echo "Invoking AgentCore with payload:"
          echo "$PAYLOAD" | jq .

          # Invoke AgentCore using boto3 Python script
          # The agent will:
          # 1. Clone/pull the agent-runtime branch on EFS
          # 2. Build the feature based on issue description
          # 3. Run tests
          # 4. Push commits to agent-runtime branch (with Ref: #N)

          # Note: Using direct boto3 API call instead of CLI
          # This eliminates dependency on .bedrock_agentcore.yaml

          # Upgrade boto3 to ensure bedrock-agentcore service is available
          echo "ðŸ“¦ Upgrading boto3 to latest version..."
          pip install --upgrade boto3 -q

          python3 .github/scripts/invoke_agent.py \
            --agent-arn "arn:aws:bedrock-agentcore:us-west-2:128673662201:runtime/antodo_agent-0UyfaL5NVq" \
            --session-id "$SESSION_ID" \
            --payload "$PAYLOAD" \
            --region us-west-2

          # Check exit code
          if [ $? -eq 0 ]; then
            echo "success=true" >> $GITHUB_OUTPUT
          else
            echo "Agent invocation failed"
            echo "success=false" >> $GITHUB_OUTPUT
            exit 1
          fi
